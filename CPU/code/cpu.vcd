$date
	Sat Jan  6 16:16:30 2018
$end
$version
	Icarus Verilog
$end
$timescale
	100fs
$end
$scope module cpu $end
$var wire 1 ! exception $end
$var reg 1 " clock $end
$var integer 32 # cycle [31:0] $end
$var integer 32 $ i [31:0] $end
$scope module CDBadd $end
$var wire 6 % robNum [5:0] $end
$var wire 1 & enable $end
$var wire 32 ' data [31:0] $end
$var reg 32 ( data_out [31:0] $end
$var reg 1 ) iscast_out $end
$var reg 6 * robNum_out [5:0] $end
$upscope $end
$scope module CDBlw $end
$var wire 6 + robNum [5:0] $end
$var wire 1 , enable $end
$var wire 32 - data [31:0] $end
$var reg 32 . data_out [31:0] $end
$var reg 1 / iscast_out $end
$var reg 6 0 robNum_out [5:0] $end
$upscope $end
$scope module addRS $end
$var wire 32 1 CDBdata [31:0] $end
$var wire 32 2 CDBdata2 [31:0] $end
$var wire 1 ) CDBiscast $end
$var wire 1 / CDBiscast2 $end
$var wire 6 3 CDBrobNum [5:0] $end
$var wire 6 4 CDBrobNum2 [5:0] $end
$var wire 1 " clock $end
$var wire 32 5 value [31:0] $end
$var wire 6 6 robNum [5:0] $end
$var wire 1 7 reset $end
$var wire 1 8 ready $end
$var wire 6 9 q2 [5:0] $end
$var wire 6 : q1 [5:0] $end
$var wire 7 ; operatorType [6:0] $end
$var wire 3 < operatorSubType [2:0] $end
$var wire 1 = operatorFlag $end
$var wire 1 > funcUnitEnable $end
$var wire 32 ? data2 [31:0] $end
$var wire 32 @ data1 [31:0] $end
$var reg 1 A available $end
$var reg 1 B breakmark $end
$var reg 1 & broadcast $end
$var reg 1 C currentRobNum $end
$var reg 32 D data1_tmp [31:0] $end
$var reg 32 E data2_tmp [31:0] $end
$var reg 32 F data_out [31:0] $end
$var reg 6 G index [5:0] $end
$var reg 6 H q1_tmp [5:0] $end
$var reg 6 I q2_tmp [5:0] $end
$var reg 6 J robNum_out [5:0] $end
$var integer 32 K i [31:0] $end
$upscope $end
$scope module bneRS $end
$var wire 32 L CDBdata [31:0] $end
$var wire 32 M CDBdata2 [31:0] $end
$var wire 1 ) CDBiscast $end
$var wire 1 / CDBiscast2 $end
$var wire 6 N CDBrobNum [5:0] $end
$var wire 6 O CDBrobNum2 [5:0] $end
$var wire 1 " clock $end
$var wire 1 P operatorFlag $end
$var wire 3 Q operatorSubType [2:0] $end
$var wire 32 R value [31:0] $end
$var wire 6 S robNum [5:0] $end
$var wire 1 7 reset $end
$var wire 1 T ready $end
$var wire 6 U q2 [5:0] $end
$var wire 6 V q1 [5:0] $end
$var wire 7 W operatorType [6:0] $end
$var wire 1 > funcUnitEnable $end
$var wire 32 X data2 [31:0] $end
$var wire 32 Y data1 [31:0] $end
$var reg 1 Z available $end
$var reg 1 [ bneResultEnable $end
$var reg 1 \ breakmark $end
$var reg 32 ] data1_tmp [31:0] $end
$var reg 32 ^ data2_tmp [31:0] $end
$var reg 32 _ data_out [31:0] $end
$var reg 6 ` index [5:0] $end
$var reg 6 a q1_tmp [5:0] $end
$var reg 6 b q2_tmp [5:0] $end
$var reg 6 c robNum_out [5:0] $end
$var integer 32 d i [31:0] $end
$upscope $end
$scope module branchPredictor $end
$var wire 1 e branchWriteEnable $end
$var wire 2 f branchWriteData [1:0] $end
$var wire 32 g branchWriteAddr [31:0] $end
$var wire 32 h branchROBReadAddr [31:0] $end
$var wire 32 i branchPCReadAddr [31:0] $end
$var reg 1 j branchPCPredict $end
$var reg 2 k branchROBPredict [1:0] $end
$var integer 32 l i [31:0] $end
$upscope $end
$scope module dataMemory $end
$var wire 1 " clock $end
$var wire 3 m writeType [2:0] $end
$var wire 1 n writeRequest $end
$var wire 32 o writeData [31:0] $end
$var wire 32 p writeAddress [31:0] $end
$var wire 32 q readAddress [31:0] $end
$var wire 32 r readAddr [31:0] $end
$var reg 32 s data_out [31:0] $end
$var reg 32 t loadUnit_out [31:0] $end
$var reg 32 u readAddrOffset [31:0] $end
$var reg 1 v readEnable $end
$var reg 32 w writeAddrOffset [31:0] $end
$var reg 1 x writeDone $end
$var integer 32 y i [31:0] $end
$upscope $end
$scope module instructionDecode $end
$var wire 1 " clock $end
$var wire 32 z instr [31:0] $end
$var wire 1 { decodePulse $end
$var wire 1 | available $end
$var reg 1 } ROBissueValid $end
$var reg 1 ~ ava $end
$var reg 32 !" data1 [31:0] $end
$var reg 32 "" data2 [31:0] $end
$var reg 5 #" destreg [4:0] $end
$var reg 32 $" instr_out [31:0] $end
$var reg 1 %" notfull $end
$var reg 1 = operatorFlag $end
$var reg 3 &" operatorSubType [2:0] $end
$var reg 7 '" operatorType [6:0] $end
$var reg 5 (" reg1 [4:0] $end
$var reg 5 )" reg2 [4:0] $end
$var reg 1 *" regstatusEnable $end
$upscope $end
$scope module instructionFetch $end
$var wire 32 +" pc [31:0] $end
$var reg 32 ," instr [31:0] $end
$var reg 1 -" isdone $end
$var integer 32 ." i [31:0] $end
$upscope $end
$scope module loadRS $end
$var wire 32 /" cdbData [31:0] $end
$var wire 32 0" cdbData2 [31:0] $end
$var wire 1 ) cdbIscast $end
$var wire 1 / cdbIscast2 $end
$var wire 6 1" cdbRobNum [5:0] $end
$var wire 6 2" cdbRobNum2 [5:0] $end
$var wire 1 " clock $end
$var wire 1 = operatorFlag $end
$var wire 3 3" operatorSubType [2:0] $end
$var wire 7 4" operatorType [6:0] $end
$var wire 32 5" value [31:0] $end
$var wire 1 7 reset $end
$var wire 1 6" ready $end
$var wire 6 7" q [5:0] $end
$var wire 32 8" offset_in [31:0] $end
$var wire 1 > funcUnitEnable $end
$var wire 6 9" destRobNum [5:0] $end
$var wire 32 :" data [31:0] $end
$var wire 1 ;" busy $end
$var reg 1 <" available $end
$var reg 1 =" breakmark $end
$var reg 6 >" currentRobNum [5:0] $end
$var reg 32 ?" data_out [31:0] $end
$var reg 32 @" data_tmp [31:0] $end
$var reg 6 A" index [5:0] $end
$var reg 1 B" loadEnable $end
$var reg 6 C" q_tmp [5:0] $end
$var reg 6 D" robNum_out [5:0] $end
$var reg 3 E" type_out [2:0] $end
$var integer 32 F" i [31:0] $end
$upscope $end
$scope module loadUnit $end
$var wire 32 G" addr [31:0] $end
$var wire 1 " clock $end
$var wire 32 H" data_in [31:0] $end
$var wire 1 B" loadEnable $end
$var wire 3 I" loadType [2:0] $end
$var wire 6 J" robNum [5:0] $end
$var reg 32 K" addr_out [31:0] $end
$var reg 1 ;" busy $end
$var reg 1 , cdbEnable $end
$var reg 32 L" cdbdata [31:0] $end
$var reg 6 M" robNum_out [5:0] $end
$upscope $end
$scope module pcControl $end
$var wire 1 A addempty $end
$var wire 1 Z bneempty $end
$var wire 1 " clock $end
$var wire 1 j jump $end
$var wire 32 N" jumppc [31:0] $end
$var wire 1 <" lwempty $end
$var wire 1 = operatorFlag $end
$var wire 3 O" operatorSubType [2:0] $end
$var wire 7 P" operatorType [6:0] $end
$var wire 1 Q" swempty $end
$var wire 1 R" robempty $end
$var wire 1 S" pcChange $end
$var wire 32 T" changeData [31:0] $end
$var reg 1 | available $end
$var reg 1 { decodePulse $end
$var reg 32 U" pc [31:0] $end
$var integer 32 V" count [31:0] $end
$upscope $end
$scope module regfile $end
$var wire 32 W" data1_in [31:0] $end
$var wire 32 X" data2_in [31:0] $end
$var wire 1 = operatorFlag $end
$var wire 3 Y" operatorSubType [2:0] $end
$var wire 7 Z" operatorType [6:0] $end
$var wire 5 [" reg1 [4:0] $end
$var wire 5 \" reg2 [4:0] $end
$var wire 1 *" regEnable $end
$var wire 5 ]" ROBwriteIndex [4:0] $end
$var wire 1 ^" ROBwriteEnable $end
$var wire 32 _" ROBwriteData [31:0] $end
$var reg 32 `" data1 [31:0] $end
$var reg 32 a" data2 [31:0] $end
$var reg 32 b" offset [31:0] $end
$var integer 32 c" i [31:0] $end
$upscope $end
$scope module regstatus $end
$var wire 5 d" reg1 [4:0] $end
$var wire 5 e" reg2 [4:0] $end
$var wire 1 *" regStatusEnable $end
$var wire 6 f" writedata [5:0] $end
$var wire 5 g" writeIndex [4:0] $end
$var wire 1 h" writeEnable $end
$var wire 5 i" ROBindex [4:0] $end
$var reg 6 j" ROBstatus [5:0] $end
$var reg 1 > funcUnitEnable $end
$var reg 6 k" q1 [5:0] $end
$var reg 6 l" q2 [5:0] $end
$var integer 32 m" i [31:0] $end
$upscope $end
$scope module reorderBuffer $end
$var wire 32 n" CDBdata1 [31:0] $end
$var wire 32 o" CDBdata2 [31:0] $end
$var wire 1 ) CDBisCast1 $end
$var wire 1 / CDBisCast2 $end
$var wire 6 p" CDBrobNum1 [5:0] $end
$var wire 6 q" CDBrobNum2 [5:0] $end
$var wire 6 r" adderIndexIn [5:0] $end
$var wire 6 s" bneIndexIn [5:0] $end
$var wire 1 [ bneWriteEnable $end
$var wire 6 t" bneWriteIndex [5:0] $end
$var wire 32 u" bneWriteResult [31:0] $end
$var wire 2 v" branchPrediction [1:0] $end
$var wire 1 -" cataclysm $end
$var wire 1 " clk $end
$var wire 1 } issueValid $end
$var wire 32 w" issue_data2 [31:0] $end
$var wire 5 x" issue_destReg [4:0] $end
$var wire 1 = issue_opFlag $end
$var wire 3 y" issue_opSubType [2:0] $end
$var wire 7 z" issue_opType [6:0] $end
$var wire 32 {" issue_pc [31:0] $end
$var wire 6 |" loadIndexIn [5:0] $end
$var wire 1 x memoryWriteDone $end
$var wire 6 }" space [5:0] $end
$var wire 6 ~" statusResult [5:0] $end
$var wire 32 !# storeValue [31:0] $end
$var wire 6 "# storeRobIndex [5:0] $end
$var wire 6 ## storeIndexIn [5:0] $end
$var wire 1 $# storeEnable $end
$var wire 32 %# storeDest [31:0] $end
$var reg 1 8 adderReadyOut $end
$var reg 32 &# adderResult [31:0] $end
$var reg 1 R" available $end
$var reg 1 T bneReadyOut $end
$var reg 32 '# bneResult [31:0] $end
$var reg 32 (# branchAddr [31:0] $end
$var reg 32 )# branchWriteAddr [31:0] $end
$var reg 2 *# branchWriteData [1:0] $end
$var reg 1 e branchWriteEnable $end
$var reg 6 +# count [5:0] $end
$var reg 6 ,# head [5:0] $end
$var reg 32 -# issueNewPC [31:0] $end
$var reg 1 S" issueNewPCEnable $end
$var reg 1 6" loadReadyOut $end
$var reg 32 .# loadResult [31:0] $end
$var reg 32 /# memoryReadAddr [31:0] $end
$var reg 32 0# memoryWriteAddr [31:0] $end
$var reg 32 1# memoryWriteData [31:0] $end
$var reg 1 n memoryWriteEnable $end
$var reg 3 2# memoryWriteType [2:0] $end
$var reg 32 3# regWriteData [31:0] $end
$var reg 1 ^" regWriteEnable $end
$var reg 5 4# regWriteIndex [4:0] $end
$var reg 1 7 resetAll $end
$var reg 5 5# statusIndex [4:0] $end
$var reg 6 6# statusWriteData [5:0] $end
$var reg 1 h" statusWriteEnable $end
$var reg 5 7# statusWriteIndex [4:0] $end
$var reg 1 8# storeReadyOut $end
$var reg 32 9# storeResult [31:0] $end
$var reg 6 :# tail [5:0] $end
$var reg 2 ;# tempPrediction [1:0] $end
$var reg 1 <# worldEnd $end
$var integer 32 =# i [31:0] $end
$upscope $end
$scope module storeRS $end
$var wire 32 ># cdbdata [31:0] $end
$var wire 32 ?# cdbdata2 [31:0] $end
$var wire 1 " clock $end
$var wire 32 @# data1 [31:0] $end
$var wire 32 A# data2 [31:0] $end
$var wire 6 B# destRobNum [5:0] $end
$var wire 1 > funcUnitEnable $end
$var wire 1 ) iscast $end
$var wire 1 / iscast2 $end
$var wire 32 C# offset_in [31:0] $end
$var wire 1 = operatorFlag $end
$var wire 3 D# operatorSubType [2:0] $end
$var wire 7 E# operatorType [6:0] $end
$var wire 6 F# q1 [5:0] $end
$var wire 6 G# q2 [5:0] $end
$var wire 1 8# ready $end
$var wire 1 7 reset $end
$var wire 6 H# robNum [5:0] $end
$var wire 6 I# robNum2 [5:0] $end
$var wire 32 J# value [31:0] $end
$var reg 1 Q" available $end
$var reg 1 K# breakmark $end
$var reg 32 L# data1_out [31:0] $end
$var reg 32 M# data1_tmp [31:0] $end
$var reg 32 N# data2_out [31:0] $end
$var reg 32 O# data2_tmp [31:0] $end
$var reg 6 P# index [5:0] $end
$var reg 6 Q# q1_tmp [5:0] $end
$var reg 6 R# q2_tmp [5:0] $end
$var reg 6 S# robNum_out [5:0] $end
$var reg 1 $# storeEnable $end
$var integer 32 T# i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100 T#
bx S#
bx R#
bx Q#
bx P#
bx O#
bx N#
bx M#
bx L#
xK#
bx J#
bx I#
bx H#
b10000 G#
b10000 F#
bx E#
bx D#
bx C#
b0 B#
bx A#
bx @#
bx ?#
bx >#
b1111 =#
x<#
bx ;#
b0 :#
bx 9#
x8#
bx 7#
bx 6#
bx 5#
bx 4#
bx 3#
bx 2#
bx 1#
bx 0#
bx /#
bx .#
bx -#
b0 ,#
b0 +#
bx *#
bx )#
bx (#
bz '#
bz &#
bx %#
0$#
bx ##
bx "#
bx !#
bx ~"
b0 }"
bx |"
b11111111111111111111111111111111 {"
bx z"
bx y"
bx x"
bx w"
bx v"
bx u"
bx t"
b10000 s"
b10000 r"
bx q"
bx p"
bx o"
bx n"
b100000 m"
b10000 l"
b10000 k"
bx j"
bx i"
0h"
bx g"
bx f"
bx e"
bx d"
b100000 c"
bx b"
bx a"
bx `"
bx _"
0^"
bx ]"
bx \"
bx ["
bx Z"
bx Y"
bx X"
bx W"
b1100100 V"
b11111111111111111111111111111111 U"
bx T"
0S"
1R"
1Q"
bx P"
bx O"
bx N"
bx M"
bx L"
bx K"
bx J"
bx I"
bx H"
bx G"
b100 F"
bx E"
bx D"
bx C"
0B"
bx A"
bx @"
bx ?"
bx >"
x="
1<"
0;"
bx :"
b0 9"
bx 8"
b10000 7"
x6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
b10000000 ."
0-"
bx ,"
b11111111111111111111111111111111 +"
0*"
bx )"
bx ("
bx '"
bx &"
x%"
bx $"
bx #"
bx ""
bx !"
x~
0}
1|
1{
bx z
b10000000000 y
1x
bx w
1v
bx u
bx t
bx s
bx r
bx q
bx p
bx o
xn
bx m
b10000000000 l
bx k
xj
b11111111111111111111111111111111 i
bx h
bx g
bx f
0e
b100 d
bx c
bx b
bx a
b10000 `
bx _
bx ^
bx ]
x\
0[
1Z
bx Y
bx X
bx W
b10000 V
b10000 U
0T
b0 S
bz R
bz Q
zP
bx O
bx N
bx M
bx L
b100 K
bx J
bx I
bx H
b10000 G
bx F
bx E
bx D
xC
xB
1A
bx @
bx ?
0>
x=
bx <
bx ;
b10000 :
b10000 9
08
07
b0 6
bz 5
bx 4
bx 3
bx 2
bx 1
bx 0
0/
bx .
bx -
0,
bx +
bx *
0)
bx (
bx '
0&
bx %
bx $
b0 #
0"
x!
$end
#10000
06"
bz 5"
bz .#
b10000 A"
b10000 |"
b0 ?
b0 X
b0 :"
b0 a"
b0 A#
b1001 8"
b1001 b"
b1001 C#
1>
b100 K
b100 T#
b1001 ""
b1001 N"
b1001 X"
b1001 w"
b0 ("
b0 ["
b0 d"
b11 #"
b11 x"
1}
1*"
b100100000010000110000011 $"
1%"
1~
1=
b10 <
b10 &"
b10 3"
b10 O"
b10 Y"
b10 y"
b10 D#
b11 ;
b11 W
b11 '"
b11 4"
b11 P"
b11 Z"
b11 z"
b11 E#
0j
b100100000010000110000011 z
b100100000010000110000011 ,"
1/
b0 i
b0 +"
b0 U"
b0 {"
1{
0C
b0 >"
1,
b100 d
0\
1"
#10001
1<"
b101 F"
1="
b10000 C"
b0 @"
#10010
b10000 j"
b10000 ~"
b1 +#
b1 6
b1 S
b1 9"
b1 }"
b1 B#
b1 :#
1h"
b0 f"
b0 6#
b11 g"
b11 7#
#15000
b0 t
1;"
b1001 r
b1001 K"
b100 K
0B
0B"
b0 D"
b0 J"
b10 E"
b10 I"
b1001 ?"
b1001 G"
b100 F"
1="
#20000
b11111111111111111111111111111111 h
b11111111111111111111111111111111 (#
b0 T"
b0 -#
0h"
0n
b1 #
0"
#30000
b100 T#
b100 K
1>
b0 8"
b0 b"
b0 C#
b0 0
b0 4
b0 O
b0 2"
b0 q"
b0 I#
1/
bx $"
b111 <
b111 &"
b111 3"
b111 O"
b111 Y"
b111 y"
b111 D#
bx ;
bx W
bx '"
bx 4"
bx P"
bx Z"
bx z"
bx E#
1*"
bx z
bx ,"
b100 d
0;"
b0 +
b0 M"
1,
1}
b1 i
b1 +"
b1 U"
b1 {"
1{
b1 >"
1C
1"
#30010
b10 +#
b10 6
b10 S
b10 9"
b10 }"
b10 B#
b10 :#
#35000
b100 F"
0="
b100 K
#40000
b1 +#
b1 ,#
b10 #
0"
#50000
1>
b100 T#
b100 K
bx ;
bx W
bx '"
bx 4"
bx P"
bx Z"
bx z"
bx E#
1*"
1/
b10 i
b10 +"
b10 U"
b10 {"
1{
1}
1,
b100 d
0C
b10 >"
1"
#50010
b10 +#
b11 6
b11 S
b11 9"
b11 }"
b11 B#
b11 :#
#55000
b100 K
b100 F"
#60000
b1010 $
b1 +#
b10 ,#
1!
1<#
b11 #
0"
