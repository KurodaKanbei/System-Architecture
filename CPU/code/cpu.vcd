$date
	Mon Jan  8 22:15:10 2018
$end
$version
	Icarus Verilog
$end
$timescale
	100fs
$end
$scope module branchPredictor $end
$var wire 32 ! branchPCReadAddr [31:0] $end
$var wire 32 " branchROBReadAddr [31:0] $end
$var wire 32 # branchWriteAddr [31:0] $end
$var wire 2 $ branchWriteData [1:0] $end
$var wire 1 % branchWriteEnable $end
$var reg 1 & branchPCPredict $end
$var reg 2 ' branchROBPredict [1:0] $end
$var integer 32 ( i [31:0] $end
$upscope $end
$scope module cpu $end
$var wire 1 ) exception $end
$var reg 1 * clock $end
$var integer 32 + cycle [31:0] $end
$var integer 32 , i [31:0] $end
$scope module CDBadd $end
$var wire 6 - robNum [5:0] $end
$var wire 1 . enable $end
$var wire 32 / data [31:0] $end
$var reg 32 0 data_out [31:0] $end
$var reg 1 1 iscast_out $end
$var reg 6 2 robNum_out [5:0] $end
$upscope $end
$scope module CDBlw $end
$var wire 6 3 robNum [5:0] $end
$var wire 1 4 enable $end
$var wire 32 5 data [31:0] $end
$var reg 32 6 data_out [31:0] $end
$var reg 1 7 iscast_out $end
$var reg 6 8 robNum_out [5:0] $end
$upscope $end
$scope module addRS $end
$var wire 32 9 CDBdata [31:0] $end
$var wire 32 : CDBdata2 [31:0] $end
$var wire 1 1 CDBiscast $end
$var wire 1 7 CDBiscast2 $end
$var wire 6 ; CDBrobNum [5:0] $end
$var wire 6 < CDBrobNum2 [5:0] $end
$var wire 1 * clock $end
$var wire 32 = value [31:0] $end
$var wire 6 > robNum [5:0] $end
$var wire 1 ? reset $end
$var wire 1 @ ready $end
$var wire 6 A q2 [5:0] $end
$var wire 6 B q1 [5:0] $end
$var wire 7 C operatorType [6:0] $end
$var wire 3 D operatorSubType [2:0] $end
$var wire 1 E operatorFlag $end
$var wire 1 F funcUnitEnable $end
$var wire 32 G data2 [31:0] $end
$var wire 32 H data1 [31:0] $end
$var reg 1 I available $end
$var reg 1 J breakmark $end
$var reg 1 . broadcast $end
$var reg 32 K data1_tmp [31:0] $end
$var reg 32 L data2_tmp [31:0] $end
$var reg 32 M data_out [31:0] $end
$var reg 6 N index [5:0] $end
$var reg 6 O q1_tmp [5:0] $end
$var reg 6 P q2_tmp [5:0] $end
$var reg 6 Q robNum_out [5:0] $end
$var integer 32 R i [31:0] $end
$upscope $end
$scope module bneRS $end
$var wire 32 S CDBdata [31:0] $end
$var wire 32 T CDBdata2 [31:0] $end
$var wire 1 1 CDBiscast $end
$var wire 1 7 CDBiscast2 $end
$var wire 6 U CDBrobNum [5:0] $end
$var wire 6 V CDBrobNum2 [5:0] $end
$var wire 1 * clock $end
$var wire 1 W operatorFlag $end
$var wire 3 X operatorSubType [2:0] $end
$var wire 32 Y value [31:0] $end
$var wire 6 Z robNum [5:0] $end
$var wire 1 ? reset $end
$var wire 1 [ ready $end
$var wire 6 \ q2 [5:0] $end
$var wire 6 ] q1 [5:0] $end
$var wire 32 ^ pcNumber [31:0] $end
$var wire 7 _ operatorType [6:0] $end
$var wire 1 F funcUnitEnable $end
$var wire 32 ` data2 [31:0] $end
$var wire 32 a data1 [31:0] $end
$var reg 1 b available $end
$var reg 1 c bneResultEnable $end
$var reg 1 d breakmark $end
$var reg 32 e data1_tmp [31:0] $end
$var reg 32 f data2_tmp [31:0] $end
$var reg 32 g data_out [31:0] $end
$var reg 6 h index [5:0] $end
$var reg 6 i q1_tmp [5:0] $end
$var reg 6 j q2_tmp [5:0] $end
$var reg 6 k robNum_out [5:0] $end
$var integer 32 l i [31:0] $end
$upscope $end
$scope module dataMemory $end
$var wire 1 * clock $end
$var wire 3 m writeType [2:0] $end
$var wire 1 n writeRequest $end
$var wire 32 o writeData [31:0] $end
$var wire 32 p writeAddress [31:0] $end
$var wire 1 q loadUnitrequest $end
$var wire 32 r loadUnitreadAddr [31:0] $end
$var reg 32 s data_out [31:0] $end
$var reg 32 t readAddr [31:0] $end
$var integer 32 u i [31:0] $end
$upscope $end
$scope module instructionDecode $end
$var wire 1 * clock $end
$var wire 32 v pcNumber [31:0] $end
$var wire 32 w instr [31:0] $end
$var wire 1 x decodePulse $end
$var wire 1 y available $end
$var reg 1 z ROBissueValid $end
$var reg 1 { ava $end
$var reg 32 | data1 [31:0] $end
$var reg 32 } data2 [31:0] $end
$var reg 5 ~ destreg [4:0] $end
$var reg 32 !" instr_out [31:0] $end
$var reg 1 "" notfull $end
$var reg 1 E operatorFlag $end
$var reg 3 #" operatorSubType [2:0] $end
$var reg 7 $" operatorType [6:0] $end
$var reg 5 %" reg1 [4:0] $end
$var reg 5 &" reg2 [4:0] $end
$var reg 1 '" regstatusEnable $end
$upscope $end
$scope module instructionFetch $end
$var wire 32 (" pc [31:0] $end
$var reg 32 )" instr [31:0] $end
$var reg 1 *" isdone $end
$var integer 32 +" i [31:0] $end
$upscope $end
$scope module loadRS $end
$var wire 32 ," cdbData [31:0] $end
$var wire 32 -" cdbData2 [31:0] $end
$var wire 1 1 cdbIscast $end
$var wire 1 7 cdbIscast2 $end
$var wire 6 ." cdbRobNum [5:0] $end
$var wire 6 /" cdbRobNum2 [5:0] $end
$var wire 1 * clock $end
$var wire 1 E operatorFlag $end
$var wire 3 0" operatorSubType [2:0] $end
$var wire 7 1" operatorType [6:0] $end
$var wire 32 2" value [31:0] $end
$var wire 1 ? reset $end
$var wire 1 3" ready $end
$var wire 6 4" q [5:0] $end
$var wire 32 5" offset_in [31:0] $end
$var wire 1 F funcUnitEnable $end
$var wire 6 6" destRobNum [5:0] $end
$var wire 32 7" data [31:0] $end
$var wire 1 8" busy $end
$var reg 1 9" available $end
$var reg 1 :" breakmark $end
$var reg 32 ;" data_out [31:0] $end
$var reg 32 <" data_tmp [31:0] $end
$var reg 6 =" index [5:0] $end
$var reg 1 >" loadEnable $end
$var reg 6 ?" q_tmp [5:0] $end
$var reg 6 @" robNum_out [5:0] $end
$var reg 3 A" type_out [2:0] $end
$var integer 32 B" i [31:0] $end
$upscope $end
$scope module loadUnit $end
$var wire 32 C" addr [31:0] $end
$var wire 1 * clock $end
$var wire 32 D" data_in [31:0] $end
$var wire 1 >" loadEnable $end
$var wire 3 E" loadType [2:0] $end
$var wire 6 F" robNum [5:0] $end
$var reg 32 G" addr_out [31:0] $end
$var reg 1 8" busy $end
$var reg 1 4 cdbEnable $end
$var reg 32 H" cdbdata [31:0] $end
$var reg 1 q readEnable $end
$var reg 6 I" robNum_out [5:0] $end
$upscope $end
$scope module pcControl $end
$var wire 1 I addempty $end
$var wire 1 b bneempty $end
$var wire 1 * clock $end
$var wire 1 9" lwempty $end
$var wire 1 J" nobrach $end
$var wire 1 E operatorFlag $end
$var wire 3 K" operatorSubType [2:0] $end
$var wire 7 L" operatorType [6:0] $end
$var wire 1 M" swempty $end
$var wire 1 N" robempty $end
$var wire 1 O" pcChange $end
$var wire 1 P" nostore $end
$var wire 1 Q" nobranch $end
$var wire 32 R" changeData [31:0] $end
$var reg 1 y available $end
$var reg 1 x decodePulse $end
$var reg 32 S" pc [31:0] $end
$upscope $end
$scope module regfile $end
$var wire 32 T" data1_in [31:0] $end
$var wire 32 U" data2_in [31:0] $end
$var wire 1 E operatorFlag $end
$var wire 3 V" operatorSubType [2:0] $end
$var wire 7 W" operatorType [6:0] $end
$var wire 5 X" reg1 [4:0] $end
$var wire 5 Y" reg2 [4:0] $end
$var wire 1 '" regEnable $end
$var wire 5 Z" ROBwriteIndex [4:0] $end
$var wire 1 [" ROBwriteEnable $end
$var wire 32 \" ROBwriteData [31:0] $end
$var reg 32 ]" data1 [31:0] $end
$var reg 32 ^" data2 [31:0] $end
$var reg 32 _" offset [31:0] $end
$var integer 32 `" i [31:0] $end
$upscope $end
$scope module regstatus $end
$var wire 5 a" reg1 [4:0] $end
$var wire 5 b" reg2 [4:0] $end
$var wire 1 '" regStatusEnable $end
$var wire 6 c" writedata [5:0] $end
$var wire 5 d" writeIndex [4:0] $end
$var wire 1 e" writeEnable $end
$var wire 5 f" ROBindex [4:0] $end
$var reg 6 g" ROBstatus [5:0] $end
$var reg 1 F funcUnitEnable $end
$var reg 6 h" q1 [5:0] $end
$var reg 6 i" q2 [5:0] $end
$var integer 32 j" i [31:0] $end
$upscope $end
$scope module reorderBuffer $end
$var wire 32 k" CDBdata1 [31:0] $end
$var wire 32 l" CDBdata2 [31:0] $end
$var wire 1 1 CDBisCast1 $end
$var wire 1 7 CDBisCast2 $end
$var wire 6 m" CDBrobNum1 [5:0] $end
$var wire 6 n" CDBrobNum2 [5:0] $end
$var wire 6 o" adderIndexIn [5:0] $end
$var wire 6 p" bneIndexIn [5:0] $end
$var wire 1 c bneWriteEnable $end
$var wire 6 q" bneWriteIndex [5:0] $end
$var wire 32 r" bneWriteResult [31:0] $end
$var wire 1 *" cataclysm $end
$var wire 1 * clk $end
$var wire 1 z issueValid $end
$var wire 32 s" issue_data2 [31:0] $end
$var wire 5 t" issue_destReg [4:0] $end
$var wire 1 E issue_opFlag $end
$var wire 3 u" issue_opSubType [2:0] $end
$var wire 7 v" issue_opType [6:0] $end
$var wire 32 w" issue_pc [31:0] $end
$var wire 6 x" loadIndexIn [5:0] $end
$var wire 32 y" pcNumber [31:0] $end
$var wire 6 z" space [5:0] $end
$var wire 6 {" statusResult [5:0] $end
$var wire 32 |" storeValue [31:0] $end
$var wire 6 }" storeRobIndex [5:0] $end
$var wire 6 ~" storeIndexIn [5:0] $end
$var wire 1 !# storeEnable $end
$var wire 32 "# storeDest [31:0] $end
$var reg 1 @ adderReadyOut $end
$var reg 32 ## adderResult [31:0] $end
$var reg 1 N" available $end
$var reg 1 [ bneReadyOut $end
$var reg 32 $# bneResult [31:0] $end
$var reg 32 %# branchAddr [31:0] $end
$var reg 32 &# branchWriteAddr [31:0] $end
$var reg 2 '# branchWriteData [1:0] $end
$var reg 1 (# branchWriteEnable $end
$var reg 6 )# count [5:0] $end
$var reg 6 *# head [5:0] $end
$var reg 32 +# issueNewPC [31:0] $end
$var reg 1 O" issueNewPCEnable $end
$var reg 1 3" loadReadyOut $end
$var reg 32 ,# loadResult [31:0] $end
$var reg 32 -# memoryReadAddr [31:0] $end
$var reg 32 .# memoryWriteAddr [31:0] $end
$var reg 32 /# memoryWriteData [31:0] $end
$var reg 1 n memoryWriteEnable $end
$var reg 3 0# memoryWriteType [2:0] $end
$var reg 1 Q" nobranch $end
$var reg 1 P" nostore $end
$var reg 32 1# regWriteData [31:0] $end
$var reg 1 [" regWriteEnable $end
$var reg 5 2# regWriteIndex [4:0] $end
$var reg 1 ? resetAll $end
$var reg 5 3# statusIndex [4:0] $end
$var reg 6 4# statusWriteData [5:0] $end
$var reg 1 e" statusWriteEnable $end
$var reg 5 5# statusWriteIndex [4:0] $end
$var reg 1 6# storeReadyOut $end
$var reg 32 7# storeResult [31:0] $end
$var reg 6 8# tail [5:0] $end
$var reg 1 9# worldEnd $end
$var integer 32 :# i [31:0] $end
$upscope $end
$scope module storeRS $end
$var wire 32 ;# cdbdata [31:0] $end
$var wire 32 <# cdbdata2 [31:0] $end
$var wire 1 * clock $end
$var wire 32 =# data1 [31:0] $end
$var wire 32 ># data2 [31:0] $end
$var wire 6 ?# destRobNum [5:0] $end
$var wire 1 F funcUnitEnable $end
$var wire 1 1 iscast $end
$var wire 1 7 iscast2 $end
$var wire 32 @# offset_in [31:0] $end
$var wire 1 E operatorFlag $end
$var wire 3 A# operatorSubType [2:0] $end
$var wire 7 B# operatorType [6:0] $end
$var wire 6 C# q1 [5:0] $end
$var wire 6 D# q2 [5:0] $end
$var wire 1 6# ready $end
$var wire 1 ? reset $end
$var wire 6 E# robNum [5:0] $end
$var wire 6 F# robNum2 [5:0] $end
$var wire 32 G# value [31:0] $end
$var reg 1 M" available $end
$var reg 1 H# breakmark $end
$var reg 32 I# data1_out [31:0] $end
$var reg 32 J# data1_tmp [31:0] $end
$var reg 32 K# data2_out [31:0] $end
$var reg 32 L# data2_tmp [31:0] $end
$var reg 6 M# index [5:0] $end
$var reg 6 N# q1_tmp [5:0] $end
$var reg 6 O# q2_tmp [5:0] $end
$var reg 6 P# robNum_out [5:0] $end
$var reg 1 !# storeEnable $end
$var integer 32 Q# i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100 Q#
bx P#
bx O#
bx N#
bx M#
bx L#
bx K#
bx J#
bx I#
xH#
bx G#
bx F#
bx E#
b10000 D#
b10000 C#
bx B#
bx A#
bx @#
b0 ?#
bx >#
bx =#
bx <#
bx ;#
b1111 :#
x9#
b0 8#
bx 7#
x6#
bx 5#
bx 4#
bx 3#
bx 2#
bx 1#
bx 0#
bx /#
bx .#
bx -#
bx ,#
bx +#
b0 *#
b0 )#
0(#
bx '#
bx &#
bx %#
bz $#
bz ##
bx "#
0!#
bx ~"
bx }"
bx |"
bx {"
b0 z"
b11111111111111111111111111111111 y"
bx x"
b11111111111111111111111111111111 w"
bx v"
bx u"
bx t"
bx s"
bx r"
bx q"
b10000 p"
b10000 o"
bx n"
bx m"
bx l"
bx k"
b100000 j"
b10000 i"
b10000 h"
bx g"
bx f"
0e"
bx d"
bx c"
bx b"
bx a"
b100000 `"
bx _"
bx ^"
bx ]"
bx \"
0["
bx Z"
bx Y"
bx X"
bx W"
bx V"
bx U"
bx T"
b11111111111111111111111111111111 S"
bx R"
1Q"
1P"
0O"
1N"
1M"
bx L"
bx K"
1J"
bx I"
bx H"
bx G"
bx F"
bx E"
bx D"
bx C"
b100 B"
bx A"
bx @"
bx ?"
0>"
bx ="
bx <"
bx ;"
x:"
19"
08"
bx 7"
b0 6"
bx 5"
b10000 4"
x3"
bx 2"
bx 1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
b10000000000 +"
0*"
bx )"
b11111111111111111111111111111111 ("
0'"
bx &"
bx %"
bx $"
bx #"
x""
bx !"
bx ~
bx }
bx |
x{
0z
1y
1x
bx w
b11111111111111111111111111111111 v
b10000000000 u
bx t
bx s
bx r
xq
bx p
bx o
xn
bx m
b100 l
bx k
bx j
bx i
b10000 h
bx g
bx f
bx e
xd
0c
1b
bx a
bx `
bx _
b11111111111111111111111111111111 ^
b10000 ]
b10000 \
0[
b0 Z
bz Y
bz X
zW
bx V
bx U
bx T
bx S
b100 R
bx Q
bx P
bx O
b10000 N
bx M
bx L
bx K
xJ
1I
bx H
bx G
0F
xE
bx D
bx C
b10000 B
b10000 A
0@
0?
b0 >
bz =
bx <
bx ;
bx :
bx 9
bx 8
07
bx 6
bx 5
04
bx 3
bx 2
01
bx 0
bx /
0.
bx -
bx ,
b0 +
0*
x)
b10000000000 (
bx '
x&
z%
bz $
bz #
bz "
bz !
$end
#10000
1I
b100 R
1J
b10000 P
b10000 O
b0 5"
b0 _"
b0 @#
1F
b11000000000000 |
b11000000000000 T"
b1 ~
b1 t"
1z
1'"
b11000010110111 !"
1""
1{
1E
b111 D
b111 #"
b111 0"
b111 K"
b111 V"
b111 u"
b111 A#
b110111 C
b110111 _
b110111 $"
b110111 1"
b110111 L"
b110111 W"
b110111 v"
b110111 B#
b11000010110111 w
b11000010110111 )"
b0 ^
b0 v
b0 ("
b0 S"
b0 w"
b0 y"
1x
b100 Q#
0H#
b100 l
0d
1*
#10010
b1 )#
b1 >
b1 Z
b1 6"
b1 z"
b1 ?#
b1 8#
0Q"
#15000
b100 Q#
b100 l
11
b0 2
b0 ;
b0 U
b0 ."
b0 m"
b0 E#
1.
b0 -
b0 Q
b100 R
1J
b100 B"
0:"
#20000
b0 )#
b1 *#
1Q"
b11111111111111111111111111111111 %#
b0 R"
b0 +#
0n
b1 +
0*
#30000
1F
bx !"
bx C
bx _
bx $"
bx 1"
bx L"
bx W"
bx v"
bx B#
1'"
bx w
bx )"
b100 l
b100 Q#
1z
b1 ^
b1 v
b1 ("
b1 S"
b1 w"
b1 y"
1x
1*
#30010
b1 )#
b10 >
b10 Z
b10 6"
b10 z"
b10 ?#
b10 8#
#35000
b100 B"
b100 R
0J
0.
#40000
b100000 ,
b0 )#
b10 *#
1)
19#
b10 +
0*
