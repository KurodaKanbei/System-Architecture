$date
	Fri Jan  5 20:37:33 2018
$end
$version
	Icarus Verilog
$end
$timescale
	100fs
$end
$scope module cpu $end
$var wire 1 ! exception $end
$var reg 1 " clock $end
$var integer 32 # cycle [31:0] $end
$scope module CDBadd $end
$var wire 6 $ robNum [5:0] $end
$var wire 1 % enable $end
$var wire 32 & data [31:0] $end
$var reg 32 ' data_out [31:0] $end
$var reg 1 ( iscast_out $end
$var reg 6 ) robNum_out [5:0] $end
$upscope $end
$scope module CDBlw $end
$var wire 6 * robNum [5:0] $end
$var wire 1 + enable $end
$var wire 32 , data [31:0] $end
$var reg 32 - data_out [31:0] $end
$var reg 1 . iscast_out $end
$var reg 6 / robNum_out [5:0] $end
$upscope $end
$scope module addRS $end
$var wire 32 0 CDBdata [31:0] $end
$var wire 32 1 CDBdata2 [31:0] $end
$var wire 1 ( CDBiscast $end
$var wire 1 . CDBiscast2 $end
$var wire 6 2 CDBrobNum [5:0] $end
$var wire 6 3 CDBrobNum2 [5:0] $end
$var wire 1 " clock $end
$var wire 32 4 value [31:0] $end
$var wire 6 5 robNum [5:0] $end
$var wire 1 6 reset $end
$var wire 1 7 ready $end
$var wire 6 8 q2 [5:0] $end
$var wire 6 9 q1 [5:0] $end
$var wire 7 : operatorType [6:0] $end
$var wire 3 ; operatorSubType [2:0] $end
$var wire 1 < operatorFlag $end
$var wire 1 = funcUnitEnable $end
$var wire 32 > data2 [31:0] $end
$var wire 32 ? data1 [31:0] $end
$var reg 1 @ available $end
$var reg 1 A breakmark $end
$var reg 1 % broadcast $end
$var reg 32 B data1_tmp [31:0] $end
$var reg 32 C data2_tmp [31:0] $end
$var reg 32 D data_out [31:0] $end
$var reg 6 E index [5:0] $end
$var reg 6 F q1_tmp [5:0] $end
$var reg 6 G q2_tmp [5:0] $end
$var reg 6 H robNum_out [5:0] $end
$var integer 32 I i [31:0] $end
$upscope $end
$scope module bneRS $end
$var wire 32 J CDBdata [31:0] $end
$var wire 32 K CDBdata2 [31:0] $end
$var wire 1 ( CDBiscast $end
$var wire 1 . CDBiscast2 $end
$var wire 6 L CDBrobNum [5:0] $end
$var wire 6 M CDBrobNum2 [5:0] $end
$var wire 1 " clock $end
$var wire 1 N operatorFlag $end
$var wire 3 O operatorSubType [2:0] $end
$var wire 32 P value [31:0] $end
$var wire 6 Q robNum [5:0] $end
$var wire 1 6 reset $end
$var wire 1 R ready $end
$var wire 6 S q2 [5:0] $end
$var wire 6 T q1 [5:0] $end
$var wire 7 U operatorType [6:0] $end
$var wire 1 = funcUnitEnable $end
$var wire 32 V data2 [31:0] $end
$var wire 32 W data1 [31:0] $end
$var reg 1 X available $end
$var reg 1 Y bneResultEnable $end
$var reg 1 Z breakmark $end
$var reg 32 [ data1_tmp [31:0] $end
$var reg 32 \ data2_tmp [31:0] $end
$var reg 32 ] data_out [31:0] $end
$var reg 6 ^ index [5:0] $end
$var reg 6 _ q1_tmp [5:0] $end
$var reg 6 ` q2_tmp [5:0] $end
$var reg 6 a robNum_out [5:0] $end
$var integer 32 b i [31:0] $end
$upscope $end
$scope module branchPredictor $end
$var wire 1 c branchWriteEnable $end
$var wire 2 d branchWriteData [1:0] $end
$var wire 32 e branchWriteAddr [31:0] $end
$var wire 32 f branchROBReadAddr [31:0] $end
$var wire 32 g branchPCReadAddr [31:0] $end
$var reg 1 h branchPCPredict $end
$var reg 2 i branchROBPredict [1:0] $end
$var integer 32 j i [31:0] $end
$upscope $end
$scope module dataCache $end
$var wire 1 " clk $end
$var wire 1 k writeEnable $end
$var wire 32 l writeData [31:0] $end
$var wire 32 m writeAddr [31:0] $end
$var wire 32 n readAddr [31:0] $end
$var wire 1 o memoryWriteDone $end
$var wire 1 p memoryReadEnable $end
$var wire 512 q memoryReadData [511:0] $end
$var reg 1 r hit $end
$var reg 32 s memoryReadAddr [31:0] $end
$var reg 32 t memoryWriteAddr [31:0] $end
$var reg 32 u memoryWriteData [31:0] $end
$var reg 1 v memoryWritePulse $end
$var reg 32 w readData [31:0] $end
$var reg 10 x readIndex [9:0] $end
$var reg 6 y readOffset [5:0] $end
$var reg 16 z readTag [15:0] $end
$var reg 32 { reserveData [31:0] $end
$var reg 6 | wordOffset [5:0] $end
$var reg 1 } writeDone $end
$var reg 10 ~ writeIndex [9:0] $end
$var reg 6 !" writeOffset [5:0] $end
$var reg 16 "" writeTag [15:0] $end
$var reg 6 #" writeWordOffset [5:0] $end
$var integer 32 $" i [31:0] $end
$upscope $end
$scope module dataMemory $end
$var wire 1 " clock $end
$var wire 32 %" readAddress [31:0] $end
$var wire 32 &" writeAddress [31:0] $end
$var wire 32 '" writeData [31:0] $end
$var wire 1 v writeRequest $end
$var wire 3 (" writeType [2:0] $end
$var reg 512 )" data_out [511:0] $end
$var reg 32 *" readAddrOffset [31:0] $end
$var reg 1 p readEnable $end
$var reg 32 +" writeAddrOffset [31:0] $end
$var reg 1 o writeDone $end
$var reg 6 ," writeWordOffset [5:0] $end
$var integer 32 -" i [31:0] $end
$var integer 32 ." readCount [31:0] $end
$var integer 32 /" writeCount [31:0] $end
$upscope $end
$scope module instructionDecode $end
$var wire 1 " clock $end
$var wire 32 0" instr [31:0] $end
$var wire 1 1" decodePulse $end
$var wire 1 2" available $end
$var reg 1 3" ROBissueValid $end
$var reg 1 4" ava $end
$var reg 32 5" data1 [31:0] $end
$var reg 32 6" data2 [31:0] $end
$var reg 5 7" destreg [4:0] $end
$var reg 32 8" instr_out [31:0] $end
$var reg 1 9" notfull $end
$var reg 1 < operatorFlag $end
$var reg 3 :" operatorSubType [2:0] $end
$var reg 7 ;" operatorType [6:0] $end
$var reg 5 <" reg1 [4:0] $end
$var reg 5 =" reg2 [4:0] $end
$var reg 1 >" regstatusEnable $end
$upscope $end
$scope module instructionFetch $end
$var wire 32 ?" pc [31:0] $end
$var reg 32 @" instr [31:0] $end
$var reg 1 A" isdone $end
$var integer 32 B" i [31:0] $end
$upscope $end
$scope module loadRS $end
$var wire 32 C" cdbData [31:0] $end
$var wire 32 D" cdbData2 [31:0] $end
$var wire 1 ( cdbIscast $end
$var wire 1 . cdbIscast2 $end
$var wire 6 E" cdbRobNum [5:0] $end
$var wire 6 F" cdbRobNum2 [5:0] $end
$var wire 1 " clock $end
$var wire 1 < operatorFlag $end
$var wire 3 G" operatorSubType [2:0] $end
$var wire 7 H" operatorType [6:0] $end
$var wire 32 I" value [31:0] $end
$var wire 1 6 reset $end
$var wire 1 J" ready $end
$var wire 6 K" q [5:0] $end
$var wire 32 L" offset_in [31:0] $end
$var wire 1 = funcUnitEnable $end
$var wire 6 M" destRobNum [5:0] $end
$var wire 32 N" data [31:0] $end
$var wire 1 O" busy $end
$var reg 1 P" available $end
$var reg 1 Q" breakmark $end
$var reg 32 R" data_out [31:0] $end
$var reg 32 S" data_tmp [31:0] $end
$var reg 6 T" index [5:0] $end
$var reg 1 U" loadEnable $end
$var reg 6 V" q_tmp [5:0] $end
$var reg 6 W" robNum_out [5:0] $end
$var integer 32 X" i [31:0] $end
$upscope $end
$scope module loadUnit $end
$var wire 32 Y" addr [31:0] $end
$var wire 1 " clock $end
$var wire 32 Z" data_in [31:0] $end
$var wire 1 r hit $end
$var wire 1 U" loadEnable $end
$var wire 6 [" robNum [5:0] $end
$var reg 32 \" addr_out [31:0] $end
$var reg 1 O" busy $end
$var reg 1 + cdbEnable $end
$var reg 32 ]" cdbdata [31:0] $end
$var reg 6 ^" robNum_out [5:0] $end
$upscope $end
$scope module pcControl $end
$var wire 1 @ addempty $end
$var wire 1 X bneempty $end
$var wire 1 " clock $end
$var wire 1 h jump $end
$var wire 32 _" jumppc [31:0] $end
$var wire 1 P" lwempty $end
$var wire 1 < operatorFlag $end
$var wire 3 `" operatorSubType [2:0] $end
$var wire 7 a" operatorType [6:0] $end
$var wire 1 b" swempty $end
$var wire 1 c" robempty $end
$var wire 1 d" pcChange $end
$var wire 32 e" changeData [31:0] $end
$var reg 1 2" available $end
$var reg 1 1" decodePulse $end
$var reg 32 f" pc [31:0] $end
$var integer 32 g" count [31:0] $end
$upscope $end
$scope module regfile $end
$var wire 32 h" data1_in [31:0] $end
$var wire 32 i" data2_in [31:0] $end
$var wire 1 < operatorFlag $end
$var wire 3 j" operatorSubType [2:0] $end
$var wire 7 k" operatorType [6:0] $end
$var wire 5 l" reg1 [4:0] $end
$var wire 5 m" reg2 [4:0] $end
$var wire 1 >" regEnable $end
$var wire 7 n" ROBwriteType [6:0] $end
$var wire 3 o" ROBwriteSubType [2:0] $end
$var wire 5 p" ROBwriteIndex [4:0] $end
$var wire 1 q" ROBwriteEnable $end
$var wire 32 r" ROBwriteData [31:0] $end
$var reg 32 s" data1 [31:0] $end
$var reg 32 t" data2 [31:0] $end
$var reg 32 u" offset [31:0] $end
$var integer 32 v" i [31:0] $end
$upscope $end
$scope module regstatus $end
$var wire 5 w" reg1 [4:0] $end
$var wire 5 x" reg2 [4:0] $end
$var wire 1 >" regStatusEnable $end
$var wire 6 y" writedata [5:0] $end
$var wire 5 z" writeIndex [4:0] $end
$var wire 1 {" writeEnable $end
$var wire 5 |" ROBindex [4:0] $end
$var reg 6 }" ROBstatus [5:0] $end
$var reg 1 = funcUnitEnable $end
$var reg 6 ~" q1 [5:0] $end
$var reg 6 !# q2 [5:0] $end
$var integer 32 "# i [31:0] $end
$upscope $end
$scope module reorderBuffer $end
$var wire 32 ## CDBdata1 [31:0] $end
$var wire 32 $# CDBdata2 [31:0] $end
$var wire 1 ( CDBisCast1 $end
$var wire 1 . CDBisCast2 $end
$var wire 6 %# CDBrobNum1 [5:0] $end
$var wire 6 &# CDBrobNum2 [5:0] $end
$var wire 6 '# adderIndexIn [5:0] $end
$var wire 6 (# bneIndexIn [5:0] $end
$var wire 1 Y bneWriteEnable $end
$var wire 6 )# bneWriteIndex [5:0] $end
$var wire 32 *# bneWriteResult [31:0] $end
$var wire 2 +# branchPrediction [1:0] $end
$var wire 1 } cacheWriteDone $end
$var wire 1 A" cataclysm $end
$var wire 1 " clk $end
$var wire 1 3" issueValid $end
$var wire 32 ,# issue_data2 [31:0] $end
$var wire 5 -# issue_destReg [4:0] $end
$var wire 1 < issue_opFlag $end
$var wire 3 .# issue_opSubType [2:0] $end
$var wire 7 /# issue_opType [6:0] $end
$var wire 32 0# issue_pc [31:0] $end
$var wire 6 1# loadIndexIn [5:0] $end
$var wire 6 2# statusResult [5:0] $end
$var wire 32 3# storeValue [31:0] $end
$var wire 6 4# storeRobIndex [5:0] $end
$var wire 6 5# storeIndexIn [5:0] $end
$var wire 1 6# storeEnable $end
$var wire 32 7# storeDest [31:0] $end
$var reg 1 7 adderReadyOut $end
$var reg 32 8# adderResult [31:0] $end
$var reg 1 c" available $end
$var reg 1 R bneReadyOut $end
$var reg 32 9# bneResult [31:0] $end
$var reg 32 :# branchAddr [31:0] $end
$var reg 32 ;# branchWriteAddr [31:0] $end
$var reg 2 <# branchWriteData [1:0] $end
$var reg 1 c branchWriteEnable $end
$var reg 32 =# cacheWriteAddr [31:0] $end
$var reg 32 ># cacheWriteData [31:0] $end
$var reg 1 k cacheWriteEnable $end
$var reg 6 ?# count [5:0] $end
$var reg 6 @# head [5:0] $end
$var reg 32 A# issueNewPC [31:0] $end
$var reg 1 d" issueNewPCEnable $end
$var reg 1 J" loadReadyOut $end
$var reg 32 B# loadResult [31:0] $end
$var reg 32 C# regWriteData [31:0] $end
$var reg 1 q" regWriteEnable $end
$var reg 5 D# regWriteIndex [4:0] $end
$var reg 3 E# regWriteSubType [2:0] $end
$var reg 7 F# regWriteType [6:0] $end
$var reg 1 6 resetAll $end
$var reg 6 G# space [5:0] $end
$var reg 5 H# statusIndex [4:0] $end
$var reg 6 I# statusWriteData [5:0] $end
$var reg 1 {" statusWriteEnable $end
$var reg 5 J# statusWriteIndex [4:0] $end
$var reg 1 K# storeReadyOut $end
$var reg 32 L# storeResult [31:0] $end
$var reg 6 M# tail [5:0] $end
$var reg 2 N# tempPrediction [1:0] $end
$var reg 1 O# worldEnd $end
$var integer 32 P# i [31:0] $end
$upscope $end
$scope module storeRS $end
$var wire 32 Q# cdbdata [31:0] $end
$var wire 32 R# cdbdata2 [31:0] $end
$var wire 1 " clock $end
$var wire 32 S# data1 [31:0] $end
$var wire 32 T# data2 [31:0] $end
$var wire 6 U# destRobNum [5:0] $end
$var wire 1 = funcUnitEnable $end
$var wire 1 ( iscast $end
$var wire 1 . iscast2 $end
$var wire 32 V# offset_in [31:0] $end
$var wire 1 < operatorFlag $end
$var wire 3 W# operatorSubType [2:0] $end
$var wire 7 X# operatorType [6:0] $end
$var wire 6 Y# q1 [5:0] $end
$var wire 6 Z# q2 [5:0] $end
$var wire 1 K# ready $end
$var wire 1 6 reset $end
$var wire 6 [# robNum [5:0] $end
$var wire 6 \# robNum2 [5:0] $end
$var wire 32 ]# value [31:0] $end
$var reg 1 b" available $end
$var reg 1 ^# breakmark $end
$var reg 32 _# data1_out [31:0] $end
$var reg 32 `# data1_tmp [31:0] $end
$var reg 32 a# data2_out [31:0] $end
$var reg 32 b# data2_tmp [31:0] $end
$var reg 6 c# index [5:0] $end
$var reg 6 d# q1_tmp [5:0] $end
$var reg 6 e# q2_tmp [5:0] $end
$var reg 6 f# robNum_out [5:0] $end
$var reg 1 6# storeEnable $end
$var integer 32 g# i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b100 g#
bx f#
bx e#
bx d#
bx c#
bx b#
bx a#
bx `#
bx _#
x^#
bx ]#
bx \#
bx [#
b10000 Z#
b10000 Y#
bx X#
bx W#
bx V#
bx U#
bx T#
bx S#
bx R#
bx Q#
b1111 P#
xO#
bx N#
b0 M#
bx L#
xK#
bx J#
bx I#
bx H#
bx G#
bx F#
bx E#
bx D#
bx C#
bx B#
bx A#
b0 @#
b0 ?#
bx >#
bx =#
bx <#
bx ;#
bx :#
bz 9#
bz 8#
bx 7#
06#
bx 5#
bx 4#
bx 3#
bx 2#
bx 1#
b11111111111111111111111111111111 0#
bx /#
bx .#
bx -#
bx ,#
bx +#
bx *#
bx )#
b10000 (#
b10000 '#
bx &#
bx %#
bx $#
bx ##
b100000 "#
b10000 !#
b10000 ~"
bx }"
bx |"
0{"
bx z"
bx y"
bx x"
bx w"
b100000 v"
bx u"
bx t"
bx s"
bx r"
0q"
bx p"
bx o"
bx n"
bx m"
bx l"
bx k"
bx j"
bx i"
bx h"
b1100100 g"
b11111111111111111111111111111111 f"
bx e"
0d"
1c"
1b"
bx a"
bx `"
bx _"
bx ^"
bx ]"
bx \"
bx ["
bx Z"
bx Y"
b100 X"
bx W"
bx V"
0U"
bx T"
bx S"
bx R"
xQ"
1P"
0O"
bx N"
bx M"
bx L"
b10000 K"
xJ"
bx I"
bx H"
bx G"
bx F"
bx E"
bx D"
bx C"
b10000000 B"
0A"
bx @"
b11111111111111111111111111111111 ?"
0>"
bx ="
bx <"
bx ;"
bx :"
x9"
bx 8"
bx 7"
bx 6"
bx 5"
x4"
03"
12"
11"
bx 0"
bx /"
bx ."
b1100101 -"
bx ,"
bx +"
bx *"
bx )"
bz ("
b0 '"
b0 &"
bx %"
b1111111111 $"
bx #"
bx ""
bx !"
bx ~
x}
bx |
bx {
bx z
bx y
bx x
bx w
0v
b0 u
b0 t
bx s
xr
bx q
1p
1o
bx n
bx m
bx l
xk
b10000000000 j
bx i
xh
b11111111111111111111111111111111 g
bx f
bx e
bx d
0c
b100 b
bx a
bx `
bx _
b10000 ^
bx ]
bx \
bx [
xZ
0Y
1X
bx W
bx V
bx U
b10000 T
b10000 S
0R
bx Q
bz P
bz O
zN
bx M
bx L
bx K
bx J
b100 I
bx H
bx G
bx F
b10000 E
bx D
bx C
bx B
xA
1@
bx ?
bx >
0=
x<
bx ;
bx :
b10000 9
b10000 8
07
06
bx 5
bz 4
bx 3
bx 2
bx 1
bx 0
bx /
0.
bx -
bx ,
0+
bx *
bx )
0(
bx '
bx &
0%
bx $
b0 #
0"
x!
$end
#10000
0J"
bz I"
bz B#
b10000 }"
b10000 2#
1@
b10000 G
b1000 C
b10000 F
b0 B
1P"
b101 X"
1Q"
b10000 V"
b1000 S"
b10000 T"
b10000 1#
b1 ?#
b1 M#
1{"
b0 y"
b0 I#
b11 z"
b11 J#
b0 5
b0 Q
b0 M"
b0 G#
b0 U#
b1000 >
b1000 V
b1000 N"
b1000 t"
b1000 T#
b0 ?
b0 W
b0 s"
b0 S#
b0 L"
b0 u"
b0 V#
1=
b1000 6"
b1000 _"
b1000 i"
b1000 ,#
b100 <"
b100 l"
b100 w"
b11 7"
b11 -#
13"
1>"
b100000100110000110010011 8"
19"
14"
1<
b110 ;
b110 :"
b110 G"
b110 `"
b110 j"
b110 .#
b110 W#
b10011 :
b10011 U
b10011 ;"
b10011 H"
b10011 a"
b10011 k"
b10011 /#
b10011 X#
b100000100110000110010011 0"
b100000100110000110010011 @"
0h
b0 g
b0 ?"
b0 f"
b0 0#
11"
b100 I
1A
b100 g#
0^#
b100 b
0Z
1}
b11111111111111111111111111111111 f
b11111111111111111111111111111111 :#
b0 e"
b0 A#
0k
1"
#20000
b1 #
0"
#30000
1P"
b101 X"
1Q"
b1001 S"
1@
b1001 C
b10 ?#
b10 M#
b1 y"
b1 I#
b100 z"
b100 J#
b1 5
b1 Q
b1 M"
b1 G#
b1 U#
1=
b1001 >
b1001 V
b1001 N"
b1001 t"
b1001 T#
1(
b1000 '
b1000 0
b1000 J
b1000 C"
b1000 ##
b1000 Q#
b0 )
b0 2
b0 L
b0 E"
b0 %#
b0 [#
b1001 6"
b1001 _"
b1001 i"
b1001 ,#
b101 <"
b101 l"
b101 w"
b100 7"
b100 -#
b100100101110001000010011 8"
b110 ;
b110 :"
b110 G"
b110 `"
b110 j"
b110 .#
b110 W#
b10011 :
b10011 U
b10011 ;"
b10011 H"
b10011 a"
b10011 k"
b10011 /#
b10011 X#
1>"
b100100101110001000010011 0"
b100100101110001000010011 @"
1{"
b100 b
b100 g#
1%
b1000 &
b1000 D
b0 $
b0 H
b100 I
1A
13"
b1 g
b1 ?"
b1 f"
b1 0#
11"
1"
#40000
b10 #
0"
#50000
1P"
b101 X"
1Q"
b11 M#
b10 5
b10 Q
b10 M"
b10 G#
b10 U#
1=
bx 8"
b111 ;
b111 :"
b111 G"
b111 `"
b111 j"
b111 .#
b111 W#
bx :
bx U
bx ;"
bx H"
bx a"
bx k"
bx /#
bx X#
1>"
bx 0"
bx @"
b1001 '
b1001 0
b1001 J
b1001 C"
b1001 ##
b1001 Q#
b1 )
b1 2
b1 L
b1 E"
b1 %#
b1 [#
1(
b10 g
b10 ?"
b10 f"
b10 0#
11"
13"
b1001 &
b1001 D
b1 $
b1 H
b100 I
1A
1%
b100 g#
b100 b
b10 ?#
b1 @#
0q"
b0 o"
b0 E#
b10011 n"
b10011 F#
b1000 r"
b1000 C#
b11 p"
b11 D#
b11 |"
b11 H#
0{"
1"
#60000
b11 #
0"
#70000
1P"
b101 X"
1Q"
b100 M#
b11 5
b11 Q
b11 M"
b11 G#
b11 U#
1=
bx :
bx U
bx ;"
bx H"
bx a"
bx k"
bx /#
bx X#
1>"
b10 ?#
b10 @#
0q"
b1001 r"
b1001 C#
b100 p"
b100 D#
b100 |"
b100 H#
b100 b
b100 g#
b100 I
0A
0%
13"
b11 g
b11 ?"
b11 f"
b11 0#
11"
1"
#80000
b100 #
0"
#90000
1P"
b101 X"
1Q"
b101 M#
b100 5
b100 Q
b100 M"
b100 G#
b100 U#
1=
bx :
bx U
bx ;"
bx H"
bx a"
bx k"
bx /#
bx X#
1>"
b100 g
b100 ?"
b100 f"
b100 0#
11"
13"
b100 I
b100 g#
b100 b
b10 ?#
b11 @#
1!
1O#
1"
